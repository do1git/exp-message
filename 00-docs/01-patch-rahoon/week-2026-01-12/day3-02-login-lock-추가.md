# 패치노트 - 2026-01-14

## 목표했던 내용 1

- 로그인 실패 추적에 분산 락(Distributed Lock) 방식 도입
- day2-02에서 분석한 분산 락 방식 실제 구현 및 성능 검증

## 변경사항 1

### 분산 락 구현

- `LockRepository` 인터페이스 및 `LockRepositoryImpl` (Redis 구현체) 추가
  - `acquireLock(key: String, ttl: Duration): LockToken?` - 락 획득
  - `acquireLocks(keys: List<String>, ttl: Duration): LockToken?` - 다중 키 락 획득
  - `releaseLock(token: LockToken): Boolean` - 락 해제 (토큰 기반, 자신의 락만 해제 가능)
- `Lock` 유틸리티 클래스로 편리한 락 사용 지원
- Redis Lua 스크립트를 통한 원자적 락 획득/해제 구현
  - email, ipAddress 기반 이중 락 적용 (예: `login:$email`, `login:$ipAddress`)

### 로그인 플로우 수정

- `AuthTokenApplicationService.loginWithLock()` 분산 락 적용
  1. `checkAndThrowIfLocked()`: 잠금 상태 확인
  2. `Lock.execute()` 내부에서 `acquireLocks()`: 락 획득 시도 (실패 시 즉시 차단)
  3. `checkAndThrowIfLocked()`: 락 획득 후 재확인
  4. `getUser()`: 사용자 조회
  5. (실패 시) `incrementFailureCount()`: 실패 카운트 증가
  6. (성공 시) `resetFailureCount()`: 실패 카운트 초기화
  7. `releaseLock()`: 락 해제 (`Lock.execute()`의 `finally`에서 수행)

## 테스트 결과 (`04-test/01-speed-login`)

20 VU가 동일 계정으로 동시 로그인 실패 공격 시뮬레이션

| 항목 | `/auth/login-without-lock` (락 없음) | `/auth/login` (락 있음) |
|------|-------------------|----------------------------|
| USER_001 (실패 처리) | 4개 | 1개 |
| LOCKED (잠금) | 16개 | 19개 |
| 평균 응답 시간 | 75.34ms | 17.3ms |
| P95 응답 시간 | 92.05ms | 20.8ms |

## 성능 비교

| 항목 | 재확인 방식 (기존) | 분산 락 방식 (신규) |
|------|-------------------|---------------------|
| Race Condition | 발생 (4회 중복) | 방지 (1회만 처리) |
| 응답 시간 | 75.34ms | 17.3ms (상당한 개선!) |
| MySQL 조회 | 항상 수행 | 락 실패 시 생략 |
| 구현 복잡도 | 낮음 | 높음 |

## 분석

- USER_001 4번 vs 1번
  - 락이 없는 경우 마지막에 실패 처리 횟수를 다시 카운팅하기 때문에 횟수가 더 작을 수 있음
  - 락이 있는 경우 현재 waiting(대기)이 없기 때문에 동시 요청은 첫번째를 제외하면 대부분 즉시 차단됨
  - 참고: 테스트 스크립트 기준 `LOCKED`에는 **계정 잠금**뿐 아니라 **락 획득 실패(경합으로 인한 즉시 차단)**도 포함될 수 있음

- 평균 응답시간
  - 기대와 같이 락이 있는 경우 평균 응답 시간이 더 작음
  - Mysql 조회 횟수가 적기 때문

## 재현 시 주의사항

- `/auth/login-without-lock` 엔드포인트는 현재 `AuthController.kt`에서 주석 처리되어 있어, 동일 조건으로 재현하려면 테스트 목적에 한해 임시로 활성화가 필요

## 피드백

### 잘한 점

- 동시 로그인 실패 요청에서 Race Condition을 제거해 중복 실패 처리(4 → 1)를 방지
- 락 실패 시 DB 조회를 생략하도록 만들어 평균 응답 시간 75.34ms → 17.3ms로 개선
- `LockRepository`/`LockToken`/Lua 스크립트로 “획득/해제” 책임이 명확해져 재사용 가능한 형태로 정리
- 락을 “획득 후 재확인” 흐름으로 배치해서, 체크-락 사이의 틈을 한 번 더 줄이는 방어적인 플로우를 구성
- email + ipAddress 이중 키 락으로 공격 패턴(동일 계정/동일 IP)에 유연하게 대응할 수 있게 설계
- 동시성 이슈를 “애플리케이션 로직”이 아니라 “원자 연산(Lua)”로 밀어 넣어서 재현/검증 가능한 형태로 만든 점이 좋음

### 아쉬운 점

- Redis + Lua 기반 분산 락 도입으로 구현/운영 복잡도가 증가(장애·타임아웃·TTL 튜닝 등 고려 지점 확대)
- 락 충돌 시 즉시 차단 방식이라, 상황에 따라 사용자 경험이 “대기”가 아닌 “거절”로 느껴질 수 있음
- TTL/클럭/네트워크 지연에 따라 “락이 너무 빨리 풀리거나(중복 실행 위험) 너무 늦게 풀리는(불필요 차단)” 튜닝 이슈가 생길 수 있음
- 락 키/TTL/획득 실패율 같은 관측 지표가 없으면 운영 중 원인 파악이 어려울 수 있어, 메트릭/로그 설계가 필요

## 추후 개선 아이디어

- 락 획득 실패(경합)와 “계정 잠금”을 에러 코드/메트릭에서 분리
  - 예: 락 획득 실패 시 `LOCK_BUSY`(또는 `LOGIN_LOCK_BUSY`) 같은 별도 코드로 응답
  - 운영 관점에서 “실제 잠금 증가” vs “락 경합 증가”를 분리해 관측 가능(대시보드/알람 품질 개선)
  - 테스트 스크립트에서도 `LOCKED`로 뭉치지 말고 별도 카운터로 분리 집계하면 결과 해석이 명확해짐

- 락 획득 실패 시 “즉시 차단” 대신 “최대 대기 시간”을 두고 재시도 옵션 추가
  - 예: `waitTimeout`(예: 200~500ms) 내에서 `retryInterval`(지수 백오프 + 지터)로 재시도
  - Kotlin이라면 busy-wait/`Thread.sleep` 대신 코루틴 `delay` 기반으로 구현(요청 스레드 점유 최소화)
  - 대기 도입 시에도 전체 응답 시간이 길어지지 않도록 상한을 강하게 두고(최대 대기), 메트릭으로 충돌률/대기시간을 관측
  - (대안) Redis Pub/Sub로 “unlock 이벤트”를 발행해 대기 효율 개선
    - `releaseLock()` 시 `PUBLISH lock:released:{key}` 같은 채널로 신호 발행 → 대기 측은 `SUBSCRIBE` 후 재시도
    - Pub/Sub는 유실 가능(구독 전 발행, 재연결 등)하니 **최대 대기시간 + 주기적 재확인(폴백)** 을 같이 두는 게 안전
