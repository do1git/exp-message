# 패치노트 - 2026-01-15

## 문제 상황 / 결정 사항

### 1) 전체 조회로 인한 성능 리스크

- **문제 상황**: 목록 조회가 전체 조회(List 반환)라 데이터가 커지면 DB/메모리/네트워크 비용이 급증
- **결정 사항**: 목록 조회는 **커서 기반 페이징을 기본/표준**으로 적용 (Offset 기반은 원칙적으로 미지원)

### 2) cursor/limit의 Optional 처리

- **문제 상황**: 첫 페이지는 커서가 없고, limit을 매번 보내기 귀찮거나(클라이언트) 서버가 기본값을 가져야 함
- **결정 사항**:
  - `cursor`: Optional (미지정 시 첫 페이지)
  - `limit`: Optional (미지정 시 기본값 적용)

### 3) cursor 타입과 내부 포맷

- **문제 상황**: cursor를 숫자/id로 노출하면 정렬 기준 변경/확장에 취약하고, 형식도 API마다 달라질 수 있음
- **결정 사항**:
  - 요청/응답 `cursor`는 항상 `String`
  - 내부 포맷은 **queryParam payload → Base64URL 인코딩**
    - payload 공통 필드:
      - `v`: 버전
      - `sk`: **커서 키(정렬 키) 목록** (콤마로 구분되며, **순서가 의미 있음**)
      - `{key}={value}`: `sk`에 포함된 각 커서 키의 값들 (필요 시 확장 가능)
    - 예시(payload): `v=1&sk=createdAt,id&createdAt=1736900000123&id=12345`
    - 예시(cursor): `base64url(payload)` (URL-safe, 필요 시 padding 제거)

### 4) limit 처리 규칙(기본값/최대값)

- **문제 상황**: limit을 무한정 허용하면 DoS/비용 문제가 생김
- **결정 사항**:
  - 기본 limit: 20 (미지정 시)
  - 최대 limit: 100
  - 최대 초과 시 clamp

### 5) 응답에 페이징 정보를 어디에 담을지(호환성)

- **문제 상황**: 현재 목록 응답의 `data`가 `List`(배열)이라 `{items,nextCursor,...}`로 바꾸면 규약이 깨질 수 있음
- **결정 사항**: **기존 body 구조(`ApiResponse`)는 유지**하고, 페이징 정보는 `pageInfo`에 담는 방향
  - (근거) JSON:API에서도 컬렉션 응답의 `data`는 배열로 두고, 페이징/부가 메타는 `links`/`meta`로 분리하는 패턴을 권장하며 X API, Stripe, Facebook Graph API 등에서도 유사 구조를 사용함
  - (왜 새 API를 만들지 않았나): v2/new endpoint로 분리하면 **클라이언트/문서/운영(라우팅·테스트) 비용이 증가**하고, 기존 API와의 **중복 유지보수**가 생김. 이번 변경은 “목록 응답(data)은 그대로 두고 메타만 추가”로 **호환성 리스크를 최소화**할 수 있어 우선 이 방식으로 진행.
  - `data`: 기존과 동일하게 리스트(배열)
  - `pageInfo.nextCursor`: 다음 페이지 커서 (`null`이면 마지막 페이지)
  - `pageInfo.limit`: 실제 적용된 limit (기본값/최대값 clamp 결과)

### 6) 적용 우선순위

- **문제 상황**: 한 번에 전 API를 바꾸면 영향 범위가 커짐
- **결정 사항**: 아래 순서로 단계 적용
  - ChatRoom → Member → Message → ChatRoom(`lastMessageAt` 추가 후 정렬 기준 적용)

## 테스트 계획

- [x] 단위 테스트: 커서 페이징 경계값(첫 페이지/마지막 페이지/빈 결과)
- [x] 통합 테스트: `nextCursor`로 페이지가 끊김 없이 이어지는지 검증

## 최종 정리(현재 합의된 스펙)

- **페이징 방식**: 커서 기반(표준), Offset 기반 미지원
- **Request**
  - `cursor`: Optional String (미지정 시 첫 페이지)
  - `limit`: Optional (미지정 시 20, 최대 100, 초과 시 clamp)
- **Response**
  - `data`: 기존과 동일한 리스트(배열)
  - `pageInfo.nextCursor`: String? (`null`이면 마지막 페이지)
  - `pageInfo.limit`: Int (실제 적용된 limit)
- **cursor 포맷(내부)**
  - queryParam payload → Base64URL 인코딩
  - payload: `v`, `sk(커서 키 목록)`, `{key}={value}` (예: `ca`, `i`)
  - **인코딩 규칙**: 
    - 키와 값에 `&`, `=` 특수 문자 금지 (파싱 방해 방지)
    - 값은 Base62 인코딩 사용 (타임스탬프, ID 등) - 각 value는 Base62로 인코딩되어 특수 문자 없음
      - 타임스탬프: Long 값을 Base62로 인코딩
      - UUID: UUID 문자열을 16바이트로 파싱 후 Base62로 인코딩 (36자 → 21-22자)
    - 전체 payload를 Base64URL 인코딩하여 cursor 생성
    - 예: `v=1&sk=ca,i&ca=Base62타임스탬프&i=Base62UUID` → Base64URL 인코딩
- **우선순위**: ChatRoom → Member → Message → ChatRoom(`lastMessageAt`)

## 피드백 (현재: Message 도메인에만 적용)

### 잘한 점

- **전체 조회 리스크를 먼저 제거**: 가장 영향이 큰 목록 조회를 커서 기반으로 전환해, 데이터 증가 시 폭발하는 비용(메모리/네트워크/DB)을 구조적으로 차단
- **호환성 우선 설계**: `data`를 배열로 유지하고 `pageInfo`로 메타를 분리해, 응답 스키마 변경에 따른 클라이언트 파급을 최소화
- **확장 가능한 커서 포맷**: `cursor: String` + `v/sk` 기반 payload로 정렬 키 확장/버전업 여지를 남김
- **방어적 limit 정책 명시**: 기본값/최대값/clamp로 API 비용 상한을 문서화해 운영 리스크를 낮춤
- **테스트로 경계값을 고정**: 첫/마지막/빈 결과 및 `nextCursor` 연계 동작을 테스트 계획에 포함

### 아쉬운 점

- **도메인 간 적용 편차**: 현재 Message만 적용되어, 다른 목록 API와의 일관성이 깨지고(클라이언트 처리 분기) “표준”으로 굳히기까지 시간이 필요
- **관측(메트릭/느린 쿼리) 체계가 아직 약함**: 배포 후 효과/회귀를 수치로 확인할 기반(메트릭·슬로우쿼리·대시보드)이 아직 부족
- **커서 무결성 미보장**: cursor 변조 방지(`sig`/HMAC 검증)가 빠져 있어 악의적/비정상 요청에 대한 방어가 필요
- **중복 키/비정상 payload 방어 여지**: cursor payload에 동일 key가 중복되거나 예상치 못한 형태가 들어와도 현재는 일부가 덮어써질 수 있어(해석이 애매해짐) 디코딩 단계에서 명확히 invalid 처리하는 정책이 필요
- **정렬 안정성 리스크**: `createdAt` 정밀도/동일 timestamp가 잦을 때 커서 안정성이 흔들릴 수 있어(동률 타이브레이커 강화, 서버 시간 일관화 등) 후속 보완이 필요
- **양방향 페이징 요구 미정리**: “이전/이후” 페이지 모두가 필요해지면 전략(커서 설계/인덱스/쿼리)이 바뀔 수 있어 사전 합의가 필요

## 다음으로 해볼 것

- ~~**cursor 디코딩 강화**: 중복 key/누락 key/예상치 못한 payload 형태를 명확히 invalid 처리(현재 일부는 덮어써질 수 있음)~~ ✅ 완료
- ~~**payload 인코딩 규칙 정리**: `key=value&...` 형태에서 value URL-encoding 적용 여부를 확정하고, encode/decode를 그 규칙으로 통일~~ ✅ 완료
- ~~**cursor 무결성 추가**: payload에 `sig`(HMAC 등) 포함 및 서버 검증(변조 방지)~~ ✅ 완료
  - **구현**: HMAC-SHA256의 처음 16바이트 사용 (128비트 보안, Base62 인코딩 후 약 22자)
  - **키 이름**: `s` (짧은 키 이름으로 길이 최소화)
  - **길이 증가**: 서명 활성화 시 약 22자 추가
  - **설정**: `page-cursor.secret`, `page-cursor.signature-enabled` (기본값: 비활성화)
  - **환경변수**: `PAGE_CURSOR_SECRET`, `PAGE_CURSOR_SIGNATURE_ENABLED`
- ~~**cursor key 개선**: `createdAt` 마이크로초 정밀도 적용 (DB `DATETIME(6)`과 일치)~~ ✅ 완료
- ~~**cursor key 길이 줄이기**: 커서키의 길이가 상당히 길기 때문에 줄일 방안 강구~~ ✅ 완료
  - **키 이름 단축**: `createdAt` → `ca`, `id` → `i` (각 도메인에서 직접 관리)
  - **숫자 인코딩**: Base62 인코딩 유틸리티 추가 (`Base62Encoding`)
    - 타임스탬프: `encodeLong`/`decodeLong` 사용
    - ID(UUID): `encodeString`/`decodeString` 사용 (UUID 자동 감지 및 최적화)
      - UUID 형식 자동 감지: 36자 UUID 문자열을 16바이트로 파싱 후 Base62 인코딩
      - 효과: UUID 36자 → 약 21-22자 (약 40% 감소)
  - **Base64 인코딩 유지**: 전체 payload는 Base64URL 인코딩 유지 (각 value는 Base62 인코딩되어 특수 문자 없으므로 URL 인코딩 불필요)
  - **효과**: 커서 길이 약 30-40% 감소 (키 이름 단축 + 숫자 인코딩), UUID는 약 40% 감소
    - 기존: `dj0xJnNrPWNyZWF0ZWRBdCxpZCZjcmVhdGVkQXQ9MTc2ODQ3NjIxNjEzMCZpZD1kNTQyODY4Ny1jMGNjLTRmMTctODVhNi1iNThjYWU1MDk4ZGU`
    - 변경후: `dj0xJnNrPWNhLGkmY2E9ODZCMHhkV0NlJmk9d2RxWWJLUlFMa1FmanFDeWx2c08zYQ`
- **관측/회귀 감시 붙이기**: API별 결과 건수, limit 분포, nextCursor 반환 비율, 느린 쿼리 감지 등을 메트릭/대시보드로 추가
  - 추후 모니터링 추가시 고려
- **가상 유저 worker 추가**: 메시지 전송/조회/스크롤 등 다양한 유저 시나리오를 지속 실행해 성능 변화·회귀를 감지하고, 추후 DB 데이터 마이그레이션(배치/스키마 변경) 테스트까지 재현 가능한 형태로 지원
  - 모니터링 추가 이후 작업 예정
- **양방향 커서 전략 검토(Message)**: “이전/이후 페이지” 모두 지원이 필요해지면 커서 설계/인덱스/쿼리를 포함해 재설계
  - 필요시 추가 개발
- **표준 확산**: ChatRoom/Member 등 다른 목록 API에도 동일한 패턴(`pageInfo`, cursor 포맷, limit 정책)을 단계 적용
  - 필요시 추가 개발
