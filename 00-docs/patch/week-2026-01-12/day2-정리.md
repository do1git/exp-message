# Day 3 작업 정리 - 2026-01-13

## 오늘 완료된 작업

1. **로그인 실패 추적 Race Condition 문제 해결**
   - read-modify-write 패턴 제거 및 원자적 증가 연산(INCR) 적용
   - 증가 후 즉시 잠금 확인 로직 추가
   - 성공한 요청도 재확인하여 동시성 문제 해결
2. **분산 락 vs 재확인 방식 성능 분석**
   - BF 공격 시나리오 기반 성능 비교
   - 재확인 방식: 40ms (Redis 2회 + MySQL 1회)
   - 분산 락 방식: 20ms (Redis 2회, MySQL 조회 없음)

## 주요 성과

- Race Condition 문제 완전 해결
  - Redis 원자적 증가 연산(INCR)으로 카운트 증가 보장
  - 증가 후 즉시 잠금 확인으로 타이밍 이슈 해결
  - 성공한 요청도 재확인하여 다른 스레드가 잠금시킨 경우 차단
- 동시성 테스트 강화
  - 20개 스레드 동시 요청 테스트로 Race Condition 검증
  - 검증 로직 완화로 동시성 환경에서의 안정성 확보
- 성능 분석 문서화
  - 분산 락과 재확인 방식의 상세한 성능 비교
  - 실무 관점에서의 선택 기준 제시

## 기술적 결정

### 재확인 방식 선택 이유

- **분산 락 대신 재확인 방식 선택**
  - 분산 락 사용 시 성능 오버헤드와 복잡도 증가
  - 원자적 증가 연산(INCR)으로 카운트 증가는 이미 보장됨
  - 증가 후 즉시 잠금 확인하여 해당 요청에 대해 잠금 적용
  - 성공한 요청도 재확인하여 다른 스레드가 잠금시킨 경우 차단
  - 더 간단하고 효율적인 방식으로 동시성 문제 해결

### 성능 분석 결과

- **BF 공격 차단 관점**: 분산 락이 2배 빠름 (20ms vs 40ms)
- **실무 관점**: 재확인 방식도 충분히 효율적
  - 대부분의 BF 공격은 첫 번째 `checkAndThrowIfLocked()`에서 차단됨
  - 구현이 단순하고 유지보수가 쉬움
  - 정상 로그인 흐름에서 오버헤드가 적음

**현재 구현(재확인 방식)을 유지해도 충분합니다.**

> 그래도 해볼까?

## 피드백

### 잘한 점

- **Race Condition 문제 체계적 해결**
  - 문제 발견 → 원인 분석 → 단계별 수정 → 검증
  - read-modify-write 패턴 문제를 정확히 파악하고 해결
  - 원자적 연산(INCR) 사용으로 근본 원인 해결
- **동시성 테스트 강화**
  - 20개 스레드 동시 요청으로 실제 Race Condition 재현
  - 검증 로직을 완화하여 동시성 환경에서의 안정성 확보
- **성능 분석 문서화**
  - 분산 락과 재확인 방식의 상세한 성능 비교
  - Redis/MySQL 요청 시간을 고려한 정확한 계산
  - 실무 관점에서의 선택 기준 명확히 제시
- **재확인 방식의 우아한 해결**
  - 분산 락 없이도 동시성 문제 해결
  - 증가 후 즉시 잠금 확인으로 타이밍 이슈 해결
  - 성공한 요청도 재확인하여 완전한 동시성 보장
- **Lua 스크립트 활용**
  - 여러 키에 대한 원자적 증가 연산 구현
  - INCR과 EXPIRE를 한 번에 처리하여 성능 최적화

### 아쉬운 점

- **초기 설계 시 Race Condition 미고려**
  - read-modify-write 패턴 사용으로 동시성 문제 발생
  - 초기 설계 단계에서 원자적 연산 고려 필요
- **테스트 시나리오 부족**
  - 동시성 테스트가 초기에 없어서 문제 발견이 늦음
  - 동시성 테스트를 초기부터 포함해야 함
- **성능 분석의 한계**
  - 실제 운영 환경과 다른 가정(10ms, 20ms) 사용
  - 실제 부하 테스트로 검증 필요

## 다음 작업 계획

- [ ] 오늘 작업한 내용을 정리하여 포트폴리오로 작성해보기
- [ ] 분산 락 방식 구현 및 성능 비교 (선택적)
- [ ] 실제 운영 환경 부하 테스트
- [ ] 로그인 실패 추적 기능 모니터링 추가
- [ ] 다른 동시성 문제 가능성 검토
