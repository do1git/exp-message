# 패치노트 - 2026-01-06

## 목표했던 내용 1

- 백엔드 서비스 개발 전략 수립

## 변경사항 1

- 백엔드 서비스 설계 전략 문서 작성 (`02-backend/README.md`)
  - 단일 서비스에서 시작하여 점진적으로 마이크로서비스로 분리하는 전략 수립
  - Phase 1: 모놀리식 시작 (빠른 프로토타이핑)
  - Phase 2: 부하 테스트 및 병목 파악
  - Phase 3: 점진적 분리 전략

## 목표했던 내용 2

- 백엔드 서비스 설계 전략 상세 정리

## 변경사항 2

- 백엔드 서비스 설계 전략 상세 문서 작성 (상세 내용은 아래 참고)

---

## 백엔드 서비스 설계 전략

## 개요

단일 서비스에서 시작하여 부하 테스트를 통해 병목 지점을 파악하고, 필요에 따라 점진적으로 마이크로서비스로 분리하는 전략입니다.

## 전략: 단일 서비스 → 점진적 분리

### Phase 1: 모놀리식 시작 (Monolithic)

**목표**: 빠른 프로토타이핑 및 핵심 기능 구현

**구조**:
- 모든 기능을 하나의 서비스에 구현
- 단일 데이터베이스 (MySQL)
- 기본적인 Redis 캐싱
- Kafka는 제외 (초기 단계에서는 불필요)

**구현 범위**:
- 사용자 인증/인가
- 채팅방 관리
- 메시지 전송/수신
- 기본적인 검색 기능 (DB 기반)
- WebSocket 실시간 통신

**장점**:
- 빠른 개발 속도
- 단순한 배포 및 운영
- 디버깅 용이
- 초기 인프라 비용 절감

### Phase 2: 부하 테스트 및 병목 파악

**목표**: 실제 부하 상황에서 병목 지점 식별

**테스트 항목**:
1. **동시 사용자 수 증가**
   - 100 → 500 → 1,000 → 5,000 → 10,000
   - 각 단계에서 성능 메트릭 수집

2. **메시지 처리량 측정**
   - 초당 메시지 수 (TPS)
   - 응답 시간 (latency)
   - 에러율

3. **리소스 모니터링**
   - CPU, Memory 사용률
   - DB 연결 수
   - 네트워크 I/O

4. **병목 지점 식별**
   - 데이터베이스 쿼리 성능
   - WebSocket 연결 관리
   - 메시지 처리 로직
   - 캐싱 전략

**도구**:
- k6를 사용한 부하 테스트
- Prometheus + Grafana로 메트릭 수집
- 프로파일링 도구 (예: JProfiler, async-profiler)

### Phase 3: 점진적 분리 전략

**분리 우선순위** (병목 지점에 따라 조정):

#### 1순위: Message Service 분리
**분리 시점**:
- 메시지 처리량이 병목이 될 때
- 메시지 저장 로직이 복잡해질 때
- 메시지 검색 기능이 필요할 때

**분리 후**:
- 독립적인 데이터베이스 (파티셔닝 적용)
- Kafka 도입 (이벤트 기반 아키텍처)
- Elasticsearch 도입 (검색 서비스 분리 준비)

#### 2순위: Search Service 분리
**분리 시점**:
- 검색 쿼리가 메인 서비스에 부하를 줄 때
- 검색 기능이 복잡해질 때
- Elasticsearch가 필요할 때

**분리 후**:
- Kafka를 통한 메시지 이벤트 구독
- Elasticsearch 전용 서비스

#### 3순위: WebSocket Service 분리
**분리 시점**:
- WebSocket 연결 관리가 복잡해질 때
- 수평 확장이 필요할 때
- Redis Pub/Sub이 필요할 때

**분리 후**:
- Redis Pub/Sub을 통한 메시지 브로드캐스팅
- 독립적인 스케일링

#### 4순위: Notification Service 분리
**분리 시점**:
- 알림 로직이 복잡해질 때
- 다양한 알림 채널이 필요할 때

#### 5순위: User Service, Chat Room Service 분리
**분리 시점**:
- 사용자 관리 로직이 복잡해질 때
- 독립적인 스케일링이 필요할 때

## 구체적인 실행 계획

### Step 1: 모놀리식 서비스 구현

**기술 스택**:
- Kotlin Spring Boot (또는 선택한 언어)
- MySQL (단일 인스턴스)
- Redis (캐싱)
- WebSocket (실시간 통신)

**구현 기능**:
1. 사용자 인증/인가 (JWT)
2. 채팅방 CRUD
3. 메시지 전송/수신
4. 메시지 조회 (페이징)
5. WebSocket 실시간 메시지 전송

### Step 2: 부하 테스트 스크립트 작성

**k6 테스트 시나리오**:
- 사용자 로그인
- 채팅방 생성/조회
- 메시지 전송 (다양한 부하)
- 메시지 조회
- WebSocket 연결 및 메시지 수신

**부하 단계**:
```javascript
// 예시: 점진적 부하 증가
stages: [
  { duration: '2m', target: 100 },   // 2분간 100명
  { duration: '5m', target: 500 },   // 5분간 500명
  { duration: '5m', target: 1000 },  // 5분간 1,000명
  { duration: '5m', target: 2000 },  // 5분간 2,000명
  { duration: '10m', target: 2000 }, // 10분간 유지
]
```

### Step 3: 모니터링 설정

**필수 메트릭**:
- 요청 처리량 (RPS)
- 응답 시간 (P50, P95, P99)
- 에러율
- CPU, Memory 사용률
- DB 연결 수 및 쿼리 성능
- WebSocket 연결 수

### Step 4: 병목 지점 분석 및 개선

**분석 항목**:
1. **데이터베이스 병목**
   - 느린 쿼리 식별
   - 인덱스 최적화
   - 연결 풀 튜닝

2. **애플리케이션 병목**
   - CPU 집약적인 작업 식별
   - 비동기 처리 도입
   - 캐싱 전략 개선

3. **네트워크 병목**
   - WebSocket 연결 관리
   - 메시지 브로드캐스팅 최적화

### Step 5: 분리 결정 기준

**분리 고려 사항**:
- ✅ 독립적인 스케일링이 필요한가?
- ✅ 다른 기술 스택이 필요한가?
- ✅ 서비스 로직이 복잡해졌는가?
- ✅ 팀이 분리되어 관리할 수 있는가?

**분리하지 않아도 되는 경우**:
- 단순한 CRUD 작업
- 낮은 트래픽
- 긴밀하게 결합된 로직

## 예상 타임라인

### Week 1-2: 모놀리식 서비스 구현
- 핵심 기능 구현
- 기본 테스트 작성

### Week 3: 부하 테스트 및 모니터링
- k6 스크립트 작성
- 모니터링 설정
- 초기 부하 테스트 실행

### Week 4: 병목 분석 및 최적화
- 성능 프로파일링
- 쿼리 최적화
- 캐싱 전략 개선

### Week 5-6: 첫 번째 분리 (Message Service)
- Message Service 분리
- Kafka 도입
- 통합 테스트

### 이후: 점진적 분리
- 필요에 따라 추가 서비스 분리
- 각 분리 후 부하 테스트 재실행

## 주의사항

1. **과도한 엔지니어링 방지**
   - 실제 필요할 때만 분리
   - YAGNI 원칙 준수

2. **데이터 일관성 고려**
   - 분리 시 데이터 동기화 전략 수립
   - 이벤트 기반 아키텍처 도입

3. **운영 복잡도 관리**
   - 분리할수록 운영 복잡도 증가
   - 모니터링 및 로깅 체계 구축

4. **팀 역량 고려**
   - 마이크로서비스 운영 역량 확보
   - 문서화 및 지식 공유

## 결론

단일 서비스에서 시작하여 실제 부하를 측정하면서 점진적으로 분리하는 접근 방식은:

✅ **실제 병목 지점을 데이터 기반으로 파악 가능**
✅ **과도한 엔지니어링 방지**
✅ **점진적 학습 및 개선**
✅ **비용 효율적**

이 전략을 통해 **"아주 튼튼한 채팅 서버"**를 효율적으로 구축할 수 있습니다.

