# 주간 패치노트 (2026-01-05)

## 1. 이번 주 진행한 내용
- **프로젝트 기반/문서 체계 구축**
  - 프로젝트 소개 `README.md` 작성 및 목표(“아주 튼튼한 채팅 서버”) 명시
  - 패치노트 디렉토리/가이드 구축 (`00-docs/patch/README.md`) 및 템플릿 정리
  - 프로젝트 전체 디렉토리 구조 초안 정리(Infra/Backend/Frontend/Test/Scripts/Docs)

- **기술 스택/아키텍처 의사결정 정리**
  - 프론트엔드: React + TypeScript 선택(백엔드 검증용 최소 UI)
  - 백엔드: Kotlin + Spring Boot 중심으로 통일(필요 시 Go/NestJS 후보)
  - 데이터: MySQL 선택 + Redis/Elasticsearch/Kafka/모니터링(Grafana 계열)/부하테스트(k6) 방향성 확정
  - MSA 목표 구조(게이트웨이/User/Chat/Message/Search/Notification/WebSocket) 및 데이터 흐름 정리
  - Database per Service 패턴 및 샤딩/파티셔닝(애플리케이션 레벨 우선 검토) 원칙 정리

- **인프라/배포 기반 구성**
  - 인프라 디렉토리 설계 원칙 정리 및 구조 문서화
  - 로컬 개발환경: Docker Compose 기반 MySQL 구성 방향 + binlog 기반 복구 전략 정리
  - k3s + Helm + ingress-nginx 설치/검증 및 로컬 레지스트리(insecure) 설정 절차 문서화
  - 모놀리식 앱 Helm 차트 + Umbrella(스택) 차트 구성(MySQL + App + Ingress)
  - 배포 스크립트 구성(`05-scripts/01_deploy_monolitic/`) 및 환경변수(.env) 기반 배포 흐름 정리
  - 실서버 인증서 만료 이슈 해결(OPNsense ACME Client로 신규 발급/적용/자동갱신 설정)

- **백엔드(모놀리식) 구현 진척**
  - 공통 예외/에러 모델 정리(DomainError/DomainException/ApplicationException) 및 트랜잭션 유틸(`Tx`) 구성
  - User 도메인 구현(엔티티/커맨드/도메인 서비스/검증/비밀번호 해싱)
  - JPA 기반 `UserRepository` 구현(Entity/JpaRepository/Impl) + 통합 테스트 작성(H2)
  - 공통 API 응답 템플릿(`ApiResponse`) + 전역 예외 처리 + Health API + E2E 테스트 구성
  - 실행 환경: MySQL datasource 설정/환경변수 주입, JDBC 드라이버/Actuator 추가, `bootRun`의 `.env` 로드 지원
  - Dockerfile(멀티 스테이지), `.dockerignore`, docker-compose(MySQL + App) 작성

## 2. AI 피드백
### 잘한점
- **문서화가 빠르고 밀도가 높음**
  - 기술 스택/아키텍처/인프라/배포까지 “선택 이유”와 “운영 관점”이 함께 남아 있어, 이후 변경에도 근거 추적이 쉬움
- **점진적 분리 전략이 현실적임**
  - 모놀리식 → 부하테스트/병목 기반 → 분리(우선순위 포함) 흐름이 과도한 엔지니어링을 피함
- **기반 코드 품질을 초기에 잡음**
  - 공통 응답/예외 처리, Health/E2E 테스트, 도메인-인프라 분리(User vs JPA Entity) 등 “초기 표준화”가 됨
- **배포/운영 이슈를 실제로 처리함**
  - 인증서 만료 같은 운영 이슈를 해결하고 자동갱신까지 구성한 점은 실서비스 관점에서 큰 진척
- **생산성 관점에서 ‘기반기 투자’가 과감하고 일관됨**
  - 문서/설계/배포판(Helm/Ingress/스크립트/공통 응답·예외/테스트)을 먼저 깔아, 이후 기능 추가 시 재작업 비용을 크게 줄이는 방향의 투자였음

### 아쉬운점
- **생산성(취준 효율) 관점에서 결과물이 아직 “말로 증명”되기 어렵다**
  - “기반기/설계+인프라 세팅” 치고는 진도가 빠른 편이지만, 면접에서 바로 보여줄 **동작 기능(유저/채팅방/메시지) + 배포/검증 증거(로그·스크린샷·수치)** 가 부족하면 평가가 깎일 수 있음
- **시간 대비 효율을 더 끌어올리려면 ‘기능 완주 + 증거 남기기’가 필요**
  - 같은 시간이라면 **REST API 2~3개를 운영환경에 올리고(배포), 모니터링/로그로 확인한 흔적**까지 남기는 쪽이 취준 관점 효율이 더 큼
- **취준 관점에서 “보여줄 수 있는 기능”의 밀도가 낮음**
  - 이번 주 산출물은 기반 작업이 많아, 포트폴리오/면접에서 바로 어필할 **유저 가입/로그인(JWT), 채팅방 CRUD, 메시지 송수신** 같은 “완주 기능”이 아직 부족해 보임
- **작업 결과의 ‘증거’가 부족함(스크린샷/로그/수치)**
  - 예: “k3s 설치/Ingress 구성”이 실제로 **도메인으로 health 체크 성공**, **Swagger 접근 성공**, **Helm upgrade 성공 로그** 같은 검증 기록으로 남으면 설득력이 크게 올라감
- **‘완료’와 ‘계획’이 문서에서 섞여 보일 수 있음**
  - 예: “k8s로 DB 구축” 문서는 절차/계획 성격이 커서, 실제 적용/검증 결과(명령/출력/이슈/해결)가 추가되면 좋음
- **주차 산출물의 단일 요약본이 더 강해질 여지가 있음**
  - 현재는 일일 문서가 잘 쌓였고, 주간 요약에서는 “이번 주에 실제로 동작 확인한 것(예: 배포 성공/헬스체크 접근)”을 체크리스트로 명확히 적으면 더 좋음
- **파일/문서 네이밍 정리 필요**
  - 오타/중복 가능성이 있는 파일명(예: `기슬` 등)과 중복 문서(…문서.md)들을 정리하면 탐색성이 좋아짐

## 3. 앞으로 진행할 내용 (우선순위 높은순서)
- **API 문서화/운영 편의**
  - SpringDoc OpenAPI(Swagger UI) 적용 및 Ingress 경로(`/api-docs`, `/swagger-ui`) 노출

- **프론트엔드 최소 기능 구축 및 배포**
  - React 기반 최소 UI 생성(서버 상태/간단한 API 호출/기본 화면)
  - 프론트엔드 Docker 이미지 빌드 파이프라인 추가
  - Helm 차트/Ingress에 프론트엔드 서비스(`/`) 라우팅 추가(백엔드 `/api`와 분리)

- **실배포/검증 루프 만들기**
  - 로컬/원격 배포 절차를 실제로 반복 실행하며 문서/스크립트 보강
  - Helm values 정리(환경별: local/remote), 배포 실패 케이스 대응 가이드 보완

- **성능/품질 기반 작업 착수**
  - k6 부하테스트 시나리오 초안 작성(로그인/메시지 전송/조회/WebSocket 등)
  - 관찰성(health/metrics/log) 최소 셋업을 “운영 가능한 수준”으로 구체화

