# 패치노트 - 2026-01-06

## 목표했던 내용 1

- 기술 스택 선정 및 프로젝트 구조 설계

## 변경사항 1

- 아키텍처 설계 문서 작성 (`docs/architecture.md`)
  - 목표 기술 스택 정의 (RDBMS 샤딩, Kafka, Elasticsearch, Redis, k8s, 부하테스트, MSA)
  - 마이크로서비스 구조 설계 (API Gateway, User, Chat Room, Message, Search, Notification, WebSocket 서비스)
  - 데이터 흐름 및 샤딩/파티셔닝 전략 수립
- 프로젝트 구조 문서 작성 (`docs/project-structure.md`)
  - MSA 기반 디렉토리 구조 설계
  - 서비스별 독립 배포 구조 정의
  - 테스트 및 인프라 구조 설계

## 목표했던 내용 2

- 프론트엔드 기술 스택 선정

## 변경사항 2

- **React + TypeScript 선택**
  - 빠른 개발: 컴포넌트 기반 구조로 채팅 UI를 빠르게 구성 가능, 최소 기능 구현에 적합
  - 빠른 유지보수: 널리 사용되는 프레임워크로 자료가 풍부하고, TypeScript로 타입 안정성 확보
  - 실시간 통신: WebSocket 통신을 위한 라이브러리 생태계가 풍부
  - API 인터페이스 검증: TypeScript로 백엔드 테스트 시 오류 감소

## 목표했던 내용 3

- 백엔드 기술 스택 선정

## 변경사항 3

- **Kotlin Spring Boot를 기본으로 통일**
  - shared 라이브러리를 가볍게 유지하기 위해 단일 언어/프레임워크로 통일
  - 엔터프라이즈급 안정성과 검증된 보안 프레임워크
  - Java 대비 간결한 문법과 null 안정성으로 런타임 오류 감소
  - Spring 생태계 활용 가능하면서도 Kotlin의 현대적 언어 기능 활용
- **추가 기술 스택 검토 중**
  - Go: 고성능 서비스(API Gateway, Message Service, WebSocket Service)를 위한 후보로 검토 중
  - NestJS (TypeScript): 비동기 처리 서비스(Search Service, Notification Service)를 위한 후보로 검토 중
  - 향후 성능 최적화가 필요한 경우 도입 고려

## 목표했던 내용 4

- RDBMS 선택 (PostgreSQL vs MySQL)

## 변경사항 4

- **RDBMS 후보 비교 검토**
  - **PostgreSQL 고려 사항**
    - JSON 지원: 메시지 메타데이터 저장에 유리한 강력한 JSON 타입 지원
    - 복잡한 쿼리: 메시지 검색 및 필터링 시 성능이 우수
    - 샤딩 솔루션: Citus 등 확장 솔루션 활용 가능 (사용 예정 x)
    - 동시성 처리: MVCC로 높은 동시 읽기/쓰기 처리에 적합
    - 확장성: 다양한 데이터 타입과 함수 지원으로 유연한 스키마 설계 가능
  - **MySQL 고려 사항**
    - 생태계: 널리 사용되어 자료와 도구가 풍부
    - 성능: 단순 쿼리에서 우수한 성능
    - 샤딩: Vitess 등 검증된 샤딩 솔루션 (사용 예정 x)
    - 운영: 널리 사용되어 운영 경험 축적 용이
  - **현재 사용 현황 고려**
    - MySQL: 많은 대기업에서 여전히 널리 사용 중 (Facebook, Twitter, Airbnb 등)
    - PostgreSQL: 점점 더 많은 기업에서 채택 중 (Apple, Instagram, Spotify 등)
    - 둘 다 강력한 생태계와 커뮤니티를 보유
  - **미래 전망 고려**
    - PostgreSQL: 오픈소스 커뮤니티에서 활발히 개발, JSON 지원과 복잡한 쿼리 성능으로 인기 증가 추세
    - MySQL: 여전히 강력한 생태계와 검증된 안정성, 많은 기업에서 계속 사용 중
    - 2년 후에도 둘 다 널리 사용될 것으로 예상되나, PostgreSQL의 성장세가 더 빠를 가능성
  - **성능 극한 최적화 관점 비교**
    - **MySQL 성능 강점**
      - 단순 읽기/쓰기 작업에서 매우 빠른 성능 (InnoDB 엔진 최적화)
      - 대용량 트래픽 처리 검증됨 (Facebook, Twitter 등)
      - 복제(Replication) 성능 우수
      - 단순 쿼리에서 매우 빠른 응답 시간
      - 채팅 서버의 대량 INSERT(메시지 저장)에 유리할 수 있음
    - **PostgreSQL 성능 강점**
      - 복잡한 쿼리와 조인에서 우수한 성능
      - MVCC 지원 (MySQL InnoDB도 지원하지만, 구현 방식이 다름)
      - 더 세밀한 격리 수준 제어 가능
      - 다양한 인덱싱 전략(GIN, GiST 등)으로 최적화 가능
      - JSON 쿼리 성능 우수
      - 분석 쿼리에서 강점
    - **MySQL 성능 강점 (추가)**
      - MVCC 지원 (InnoDB 엔진)
      - 단순 쿼리에서 매우 빠른 응답 시간
      - 복제 성능 우수
    - **채팅 서버 특성 고려**
      - 대량의 단순 INSERT(메시지 저장)가 많음 → MySQL 유리 가능
      - 빠른 SELECT(최근 메시지 조회) 중요 → MySQL 유리 가능
      - 복잡한 검색/필터링: Elasticsearch 사용 예정이므로 RDBMS 선택에 큰 영향 없음
      - 동시성 처리: 둘 다 MVCC 지원하므로 구현 방식과 설정에 따라 달라짐
      - JSON 메타데이터 저장: PostgreSQL의 JSON 타입이 더 강력하지만, 채팅 서버에서는 큰 차이 없을 수 있음
  - **MySQL 선택 결정**
    - 채팅 서버 특성상 대량의 단순 INSERT/SELECT가 많아 MySQL이 더 적합
    - Elasticsearch를 사용하므로 복잡한 검색은 RDBMS 선택에 영향 없음
    - 널리 사용되어 생태계와 자료가 풍부하며 운영 경험 축적 용이
    - 단순 쿼리에서 우수한 성능으로 채팅 서버의 빠른 응답 시간 요구사항에 부합

## 목표했던 내용 5

- 샤딩 구현 방식 검토

## 변경사항 5

- **샤딩 구현 방식 고려**
  - **애플리케이션 레벨 샤딩 (우선 검토)**
    - 애플리케이션 코드에서 샤딩 키(채팅방 ID, 사용자 ID 등)를 기반으로 직접 데이터베이스 선택
    - 서비스별로 다른 샤딩 전략 적용 가능
    - 추가 인프라 없이 구현 가능
    - 세밀한 제어 가능하지만 구현 복잡도 증가
  - **미들웨어/프록시 레벨 샤딩 (후보)**
    - Citus, Vitess, ProxySQL 등 사용
    - 자동 샤딩 관리 및 쿼리 라우팅
    - 추가 인프라 복잡도 발생
  - **결정 보류**: 애플리케이션 레벨 샤딩을 우선 검토하되, 필요 시 미들웨어 솔루션 도입 고려

## 목표했던 내용 6

- 채팅 데이터 저장 전략 검토

## 변경사항 6

- **채팅 데이터 저장 전략 고려**
  - **일반적인 패턴**
    - 최근 메시지: RDBMS(MySQL)에 저장 (빠른 조회)
    - 실시간 메시지: Redis에 캐싱 (실시간 전송)
    - 오래된 메시지: 아카이빙 (객체 스토리지, NoSQL 등)
    - 대용량 서비스: NoSQL(MongoDB, Cassandra) 또는 타임시리즈 DB 사용
  - **이 프로젝트 전략 결정**
    - 최근 메시지: MySQL에 저장 (샤딩/파티셔닝) - 성능 최적화를 위해 최근 메시지만 MySQL에 저장
    - 실시간 메시지: Redis 캐싱 - 실시간 전송을 위한 캐싱
    - 검색: Elasticsearch 인덱싱 - 복잡한 검색 요구사항 처리
    - 오래된 메시지: 아카이빙 전략 필요 (추가 검토) - 규모에 따라 도입 고려
  - **MySQL 선택 최종 결정**: 채팅 데이터 저장 전략을 고려하여 MySQL 선택 확정

## 목표했던 내용 7

- Redis 및 Elasticsearch 대안 검토

## 변경사항 7

- **Redis 대안 검토**
  - **Memcached**: 캐싱 전용이지만 Redis가 더 많은 기능 제공 (Pub/Sub, 데이터 구조 등)
  - **Hazelcast**: 인메모리 데이터 그리드이지만 채팅 서버 용도에는 과함
  - **Redis 선택**: 실시간 캐싱, Pub/Sub, 세션 관리에 최적화되어 있어 대안이 거의 없음
- **Elasticsearch 대안 검토**
  - **Apache Solr**: 검색 엔진이지만 Elasticsearch가 더 널리 사용되고 생태계가 풍부
  - **OpenSearch**: AWS의 Elasticsearch 포크이지만 Elasticsearch가 더 표준
  - **Meilisearch**: 경량 검색 엔진이지만 대규모 채팅 서버에는 부족할 수 있음
  - **Elasticsearch 선택**: 검색 엔진으로 가장 널리 사용되며, 채팅 메시지 검색에 최적화
- **결정**: Redis와 Elasticsearch 모두 채팅 서버에 최적화된 선택으로 추가 검토 불필요

## 목표했던 내용 8

- Kafka 대안 검토 (SQS, RabbitMQ 등)

## 변경사항 8

- **Kafka 대안 검토**
  - **AWS SQS**: 관리형 서비스로 간단하지만, 이벤트 스트리밍 기능 제한적, 처리량이 Kafka 대비 낮을 수 있음
  - **RabbitMQ**: 전통적인 메시지 브로커, 안정적이지만 대량 이벤트 처리 시 Kafka 대비 처리량이 낮을 수 있음
  - **Apache Pulsar**: Kafka와 유사하지만 생태계가 상대적으로 작음
  - **Kafka 선택 이유**
    - 이벤트 스트리밍에 특화: 메시지 이벤트를 여러 서비스가 구독하는 구조에 최적
    - 높은 처리량: 대량의 메시지 이벤트를 처리하는 채팅 서버에 적합
    - 이벤트 로그 저장: 이벤트를 로그로 저장하여 재처리 가능
    - 여러 서비스가 동일 이벤트를 구독하는 구조에 유리
  - **결정**: 채팅 서버의 이벤트 스트리밍 요구사항에 Kafka가 가장 적합

## 목표했던 내용 9

- 컨테이너 오케스트레이션 선택

## 변경사항 9

- **Kubernetes 선택**
  - 널리 사용되는 표준: 컨테이너 오케스트레이션의 사실상 표준으로 생태계와 자료가 풍부
  - 대안 검토 불필요: Docker Swarm, Nomad 등이 있지만 Kubernetes가 압도적으로 널리 사용됨
  - MSA 배포에 최적: 마이크로서비스 아키텍처의 독립적인 배포와 스케일링에 적합

## 목표했던 내용 10

- 모니터링 솔루션 선택

## 변경사항 10

- **모니터링 솔루션 후보군**
  - **Prometheus + Grafana**
    - 오픈소스 메트릭 수집 및 시각화
    - Kubernetes와 통합 용이
    - 널리 사용되어 자료와 커뮤니티가 풍부
    - 알림 시스템(Prometheus Alertmanager) 포함
  - **Datadog**
    - SaaS 모니터링 서비스
    - 사용 편의성이 높지만 비용 발생
    - APM, 로그, 인프라 모니터링 통합 제공
  - **New Relic**
    - APM 및 인프라 모니터링
    - SaaS 서비스로 비용 발생
    - 애플리케이션 성능 모니터링에 특화
  - **ELK Stack (Elasticsearch, Logstash, Kibana)**
    - 로그 분석 중심
    - Elasticsearch를 이미 사용 중이므로 통합 가능
    - 메트릭 수집보다는 로그 분석에 특화
    - **단점**: 높은 성능 요구사항 (Elasticsearch, Logstash가 CPU/메모리를 많이 사용)
    - 채팅 서버의 대량 로그 처리 시 리소스 부담 가능
  - **Loki (Grafana Loki)**
    - 경량 로그 수집 솔루션
    - Prometheus와 유사한 라벨 기반 쿼리
    - ELK Stack 대비 리소스 사용량이 적음
    - Grafana와 통합 가능
  - **Jaeger / Zipkin**
    - 분산 추적(Distributed Tracing) 전용
    - 마이크로서비스 간 요청 추적
    - 메트릭 수집과는 별개로 사용
  - **Grafana 패밀리 선택 결정**
    - Prometheus + Grafana: 메트릭 수집 및 시각화
    - Loki: 로그 수집 및 분석 (Grafana와 통합)
    - Grafana 패밀리로 통합 관리 가능하여 운영 편의성 향상
    - Kubernetes와 통합 용이
    - 오픈소스로 비용 부담 없음
  - **Jaeger 추후 고려**
    - 분산 추적은 초기에는 선택 사항
    - 마이크로서비스가 복잡해지면 도입 고려
    - 필요 시 추가 도입 가능

## 목표했던 내용 11

- 부하테스트 및 스트레스 테스트 도구 선택

## 변경사항 11

- **부하테스트 도구 후보군**
  - **k6**
    - 모던한 부하테스트 도구, JavaScript로 작성
    - 클라우드 네이티브, Kubernetes 통합 용이
    - WebSocket 지원 우수
    - 코드 기반으로 CI/CD 파이프라인에 통합 용이
    - 상대적으로 가벼움
  - **JMeter**
    - Java 기반, 널리 사용되는 도구
    - GUI 제공으로 초기 학습이 쉬움
    - 다양한 프로토콜 지원
    - 대규모 테스트 시 리소스 사용량이 많을 수 있음
  - **Locust**
    - Python 기반, 코드로 작성
    - 분산 테스트 지원
    - 실시간 모니터링 UI 제공
    - Python 생태계 활용 가능
  - **Gatling**
    - Scala 기반, 고성능
    - 코드 기반으로 상세한 리포트 생성
    - 학습 곡선이 다소 높을 수 있음
- **스트레스 테스트**
  - 부하테스트 도구와 동일한 도구 사용
  - 점진적으로 부하를 증가시켜 시스템 한계점 확인
  - k6의 시나리오 기능 활용 가능
- **k6 선택 결정**
  - 익숙한 도구로 빠른 시작 가능
  - WebSocket 지원으로 채팅 서버 테스트에 적합
  - Kubernetes 통합 용이
  - CI/CD 파이프라인에 통합 용이
  - 부하테스트와 스트레스 테스트 모두 k6로 진행

## 목표했던 내용 12

- RDBMS 운영 전략 결정 (Database per Service)

## 변경사항 12

- **Database per Service 패턴 채택**
  - 각 마이크로서비스마다 독립적인 MySQL 인스턴스 운영
  - 서비스 간 데이터 결합도 최소화
  - 서비스별 독립적인 스케일링 가능
  - 장애 격리: 한 서비스의 DB 장애가 다른 서비스에 영향 없음
  - 서비스별로 다른 샤딩 전략 적용 가능
  - 데이터 일관성: 서비스 간 데이터 동기화는 이벤트 기반(Kafka)으로 처리

## 목표했던 내용 13

- Redis 운영 전략 결정

## 변경사항 13

- **Redis 운영 전략 고려**
  - **서비스별 Redis 분리 (우선 검토)**
    - 각 서비스마다 독립적인 Redis 인스턴스 운영
    - 서비스별 캐싱 전략 독립적으로 관리
    - 장애 격리: 한 서비스의 Redis 장애가 다른 서비스에 영향 없음
    - 서비스별 독립적인 스케일링 가능
  - **공유 Redis (선택적)**
    - 세션 관리: 공유 Redis 사용 고려 (단일 로그인 요구사항 시)
    - Pub/Sub: WebSocket Service의 메시지 브로드캐스팅용 공유 Redis 고려
  - **결정 보류**: 기본적으로 서비스별 분리하되, 세션 관리나 Pub/Sub은 공유 Redis 사용 검토

## 목표했던 내용 14

- 데이터 저장소 분리 원칙 정리

## 변경사항 14

- **Database per Service 패턴 확장**
  - RDBMS(MySQL): 각 서비스별 독립 인스턴스 운영
  - Redis: 각 서비스별 독립 인스턴스 운영 (선택적 공유 고려)
  - NoSQL: 향후 도입 시에도 각 서비스별 독립 인스턴스 운영
  - Elasticsearch: 검색 전용이므로 Search Service에서만 사용
  - 모든 데이터 저장소에 Database per Service 패턴 적용
  - 서비스 간 데이터 공유는 이벤트 기반(Kafka)으로 처리
